<?php
/**
* This module contains custom functionality for sites that I run.
* 
* @todo List specific features here. :-)
*
* @author Douglas Muth <http://www.claws-and-paws.com/>
*/


/**
* Our init hook.
*/
function ddt_init() {

	//
	// Various debugging statements for testing.
	//
	//print "In ddt_init()"; // Debugging
	//ddt_log("test: !time", array("!time" =>  time()));
	//ddt_log("test: !time", array("!time" =>  time()), WATCHDOG_WARNING);
	//ddt_log("test: !time", array("!time" =>  time()), WATCHDOG_ERROR, l("test link", "http://test"));

	//ddt_uninstall(); // Debugging
	//ddt_install(); // Debugging
	//ddt_cron(); // Debugging

} // End of ddt_init()


/**
* Our crontab, which is run periodically.
* Right now, it just compares variables, so we can see if any of our admins
*	have changed things since the last run.
*/
function ddt_cron() {

	$old_vars = ddt_get_vars();
	$vars = variable_init();

	if (empty($old_vars)) {
		$message = t("No stored variables found.");
		ddt_log($message);

	} else {
		$fields = ddt_get_changed_vars($old_vars, $vars);
		ddt_log_changed_vars($fields);

	}

	//
	// Store our variables for the next pass.
	//
	ddt_put_vars($vars);

} // End of ddt_cron()


/**
* Compare our old and current variable arrays and see what changed.
*
* @param array $old_vars Our array of old values.
*
* @param array $vars Our array of current values
*
* @return array An associative array which holds new, deleted,
*	and changed variables.
*/
function ddt_get_changed_vars($old_vars, $vars) {

	$retval = array();
	$retval["new"] = array();
	$retval["deleted"] = array();
	$retval["changed"] = array();

	//
	// Look for new and changed values.
	//
	foreach ($vars as $key => $value) {

		if (!array_key_exists($key, $old_vars)) {
			$retval["new"][] = $key;

		} else {

			if (serialize($value) != serialize($old_vars[$key])) {
				$old_value = serialize($old_vars[$key]);
				$new_value = serialize($value);

				//
				// Cut off our serialized strings after a certain length
				// to keep from getting giant multi-megabyte strings 
				// that kill the browser.
				//
				$max_len = 1024;

				if (strlen($old_value) > $max_len) {
					$old_value = substr($old_value, 0, $max_len) 
						. t(" (truncated at !max chars)",
							array("!max" => $max_len))
					;
				}

				if (strlen($new_value) > $max_len) {
					$new_value = substr($new_value, 0, $max_len) 
						. t(" (truncated at !max chars)",
							array("!max" => $max_len))
					;
				}

				$retval["changed"][] = 
					t("Old value for '$key': ") . $old_value . ", "
					. t("New value for '$key': ") . $new_value
					;
			}

		}

	}

	foreach ($old_vars as $key => $value) {
		if (!array_key_exists($key, $vars)) {
			$retval["deleted"][] = $key;
		}
	}

	return($retval);

} // End of ddt_get_changed_vars()


/**
* Log our changed variables.
*
* @param array $fields Array of new, deleted, and changed variables.
*/
function ddt_log_changed_vars($fields) {

	if (!empty($fields["new"])) {
		$message = t("New variables: %vars",
			array("%vars" => join(", ", $fields["new"]))
			);
		ddt_log($message);
	}

	if (!empty($fields["deleted"])) {
		$message = t("Deleted variables: %vars",
			array("%vars" => join(", ", $fields["deleted"]))
			);
		ddt_log($message);
	}

	if (!empty($fields["changed"])) {
		$message = t("Changed variables: %vars",
			array("%vars" => join(", ", $fields["changed"]))
			);
		ddt_log($message);
	}

} // End of ddt_log_changed_vars()

/**
* Fetch our stored variables.
* 
* @return array Our array of stored variables.
*/
function ddt_get_vars() {

	$retval = array();

	$query = "SELECT variables FROM {ddt_variables} LIMIT 1";
	$cursor = db_query($query);
	$row = db_fetch_array($cursor);

	//
	// If we got a result, unserialize the string.
	//
	if (!empty($row)) {
		$retval = unserialize($row["variables"]);
	}

	return($retval);

} // End of ddt_get_vars()


/**
* Store our current variables in the ddt_variables table.
*
* @param array $vars Our array of variables.
*/
function ddt_put_vars($vars) {

	//
	// First, wipe out what's there.
	//
	$query = "TRUNCATE TABLE {ddt_variables}";
	db_query($query);

	//
	// Now serialize and store our current variables.
	//
	$vars = serialize($vars);
	$query = "INSERT INTO {ddt_variables} (variables) VALUES ('%s')";
	db_query($query, $vars);

} // End of ddt_put_vars()


/**
* Log when this module is enabled.
*/
function ddt_enable() {
	ddt_log("DDT Module enabled");
}


/**
* Log when this module is disabled.
*/
function ddt_disable() {
	ddt_log("DDT Module disabled");
}


/**
* This function is called whenever a node is created, changed, etc.
*/
function ddt_nodeapi($node, $op) {

	//print_r($node); // Debugging

	//
	// We only care about changes to the post
	//
	if ($op != "delete" && $op != "delete revision"
		&& $op != "insert" && $op != "update") {
		return(null);
	}

	$message = t("Op: %op on NID %nid ")
		. "(" 
			. t("Topic: %topic, ")
			. t("Published?: %published, ")
			. t("Promoted?: %promoted, ")
			. t("Sticky?: %sticky, ")
			. t("Comments allowed?: %comments") . 
		")";
	$var = array();
	$var["%nid"] = $node->nid;
	$var["%op"] = $op;
	$var["%topic"] = $node->title;
	$var["%published"] = $node->status;
	$var["%promoted"] = $node->promote;
	$var["%sticky"] = $node->sticky;
	$var["%comments"] = $node->comment;
	$link = l("view", "node/" . $node->nid);

	ddt_log($message, $var, "", $link);

} // End of ddt_nodeapi()


/**
* Hook activity on comments.
*/
function ddt_comment($comment, $op) {

	//
	// We only care about changes to the comment
	//
	if ($op != "delete" && $op != "insert" && $op != "update"
		&& $op != "publish" && $op != "unpublish"
		) {
		return(null);
	}

	$nid = "";
	$message = t("Op: %op ");
	$var = array();
	$var["%op"] = $op;

	//
	// $comment can be an array or an object based on what our operation is.
	//
	if ($op == "insert") {
		$message .= t("on CID %cid");
		$var["%cid"] = $comment["cid"];
		$nid = $comment["nid"];

	} else if ($op == "update") {
		$message .= t("on CID %cid");
		$var["%cid"] = $comment["cid"];
		$nid = $comment["nid"];

		if ($comment["status"] == 1) {
			$message .= t(" (Probably unpublishing.");
		}

	} else if ($op == "delete") {
		$message .= t("on CID %cid");
		$var["%cid"] = $comment->cid;
		$nid = $comment->nid;

	} else if ($op == "publish") {
		$message .= t("on CID %cid");
		$var["%cid"] = $comment["cid"];
		$nid = $comment["nid"];

	} else {
		//
		// catch-all in case something unexpected comes along.
		//
		$message .= t("UNKNOWN OP");

	}

	//
	// If we have a CID, set a link.
	//
	$link = "";
	if (!empty($var["%cid"])) {
		$options = array();
		$options["fragment"] = "comment-" . $var["%cid"];
		$link = l("view", "node/" . $nid, $options);
	}

	ddt_log($message, $var, "", $link);

} // End of ddt_comment()


/**
* Our user hook.
*/
function ddt_user($op, $edit, $user) {

	//
	// We only care about updates.
	//
	if ($op != "update") {
		return(null);
	}

	//
	// If we're updating an account, note if the account is disabled or not.
	//
	$status = $edit["status"];
	$uid = $user->uid;
	$name = $user->name;
	$message = t("Updating user ID !uid. ");
	if ($status == 0) {
		$message .= t("Current status: blocked");
	} else {
		$message .= t("Current status: active.");
	}

	$var = array();
	$var["!uid"] = $uid;
	$link = l("view", "user/" . $uid);

	ddt_log($message, $var, "", $link);

} // End of ddt_user()


/**
* This function is fired whenever a node or comment is flagged.
*
* @param string $action This is "flag" or "unflag"
*
* @param object $flag The flag object.  We check this to determine if a 
*	node or comment was flagged.
*
* @param integer $id The NID or CID that was flagged.
*/
function ddt_flag($action, $flag, $id) {

	$name = get_class($flag);

	if ($name == "flag_node") {

		$nid = $id;
		$var = array();
		$var["%nid"] = $nid;
		$link = l("view", "node/" . $nid);

		if ($action == "flag") {
			$message = t("Node ID %nid flagged.");
		} else {
			$message = t("Node ID %nid unflagged.");
		}

	} else if ($name == "flag_comment") {

		$cid = $id;
		$var = array();
		$var["%cid"] = $cid;

		//
		// Find the NID based on the comment
		//
		$query = "SELECT nid FROM {comments} WHERE cid=%d";
		$cursor = db_query($query, $cid);
		$row = db_fetch_array($cursor);
		$nid = $row["nid"];

		//
		// Create a link to that specific comment.
		//
		$options = array();
		$options["fragment"] = "comment-" . $cid;
		$link = l("view", "node/" . $nid, $options);

		if ($action == "flag") {
			$message = t("Comment ID %cid flagged.");
		} else {
			$message = t("Comment ID %cid unflagged.");
		}

	} else {
		//
		// If we get something unexpected, log this and stop.
		//
		$message = "Unknown classname: %name (ID: %id)";
		$var = array();
		$var["%name"] = $name;
		$var["%id"] = $id;
		ddt_log($message, $var);
		return(null);
	}

	ddt_log($message, $var, "", $link);

} // End of ddt_flag()


/**
* Hook for inserting a new private message.
*
* @param array $message An associative array of message information.
*/
function ddt_privatemsg_message_insert($message) {
	$log_message = t("New private message created. MID: %mid");
	$var = array();
	$var["%mid"] = $message["mid"];
	ddt_log($log_message, $var);
}


/**
* Hook for viewing a private message.
*
* @param array $message An associative array of message information.
*/
function ddt_privatemsg_message_load($message) {
	$log_message = t("Read private message. MID: %mid");
	$var = array();
	$var["%mid"] = $message["mid"];
	ddt_log($log_message, $var);
}


/**
* Our wrapper for watchdog()
*
* @param string $message The message, which will be passed to t().
*	For substitution, using !string is probably the way to go.
*
* @param array $variables Array of variable substituions for t().
*
* @param string $severity Valid values are WATCHDOG_NOTICE, 
*	WATCHDOG_WARNING, and WATCHDOG_ERROR.
*
* @return void
*
*/
function ddt_log($message, $variables = array(), 
	$severity = WATCHDOG_NOTICE, $url = "") {

	if ($severity == "") {
		$severity = WATCHDOG_NOTICE;
	}

	watchdog("ddt", $message, $variables, $severity, $url);

} // End of ddt_log()

